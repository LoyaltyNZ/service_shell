# This file was generated by "bin/generators/effective_date.rb" and is part
# of the historical ("effective") dating system. See the generator comments
# in "bin/generators/classes/effective_date_class.rb", the RDoc description
# of Hoodoo::ActiveRecord::Dated and Hoodoo Guides for details.
#
class <%= config[ :migration_class ] %> < ActiveRecord::Migration[5.1]
  def up
    execute <<-SQL
      create or replace function <%= config[:function_base_name] %>_<%= table_name %>()
      returns trigger
      as $$
      declare
        _now timestamp;
        new_end timestamp;
        new_start timestamp;
        error boolean;
        history_id text;

      begin
        /*
         not now(),
         see: http://www.postgresql.org/docs/9.3/static/functions-datetime.html#FUNCTIONS-DATETIME-CURRENT
         and: http://www.postgresql.org/docs/9.3/static/functions-datetime.html
        */

        _now = clock_timestamp() at time zone 'utc';

        if TG_OP = 'UPDATE' or TG_OP = 'DELETE' then
          select max(effective_end) from <%= table_name %>_history_entries where uuid=cast( old.id as text ) into new_start;
          if new_start is null then
            new_start = old.created_at;
          end if;
        end if;

        if TG_OP = 'UPDATE' then

          select exists(
            select 1 from <%= table_name %>_history_entries
            where effective_end > new.updated_at
            and uuid = cast( new.id as text )
          ) into error;

          if error then
            RAISE EXCEPTION 'The datetime in updated_at [%] is before existing history entries', new.updated_at;
          end if;

          new_end = new.updated_at;

          history_id = old.id || '_' || extract(epoch from new_end) * 100000;

          insert into <%= table_name %>_history_entries
          ( id, uuid, <%= column_names.join(', ') %>, effective_start, effective_end )
          values
          ( history_id, old.id, <%= column_names.map{ |c| "old.#{c}" }.join(', ') %>, new_start, new_end );

          return new;

        elsif TG_OP = 'INSERT' then

          select exists(select 1 from <%= table_name %>_history_entries where uuid=cast( new.id as text )) into error;

          if error then
            RAISE 'Duplicate uuid: %', new.id USING ERRCODE = 'unique_violation';
          end if;

          return new;

        elsif TG_OP = 'DELETE' then

          history_id = old.id || '_' || extract(epoch from _now) * 100000;

          insert into <%= table_name %>_history_entries
          ( id, uuid, <%= column_names.join(', ') %>, effective_start, effective_end )
          values
          ( history_id, old.id, <%= column_names.map{ |c| "old.#{c}" }.join(', ') %>, new_start, _now );

          return old;

        end if;
      end $$ language plpgsql;

    SQL
  end

  def down
    execute <<-SQL
      drop function <%= config[:function_base_name] %>_<%= table_name %>();
    SQL
  end
end
